package keyer

import (
	"encoding/hex"
	"fmt"
	"testing"

	"github.com/dfuse-io/solana-go"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestEncodeFillData(t *testing.T) {
	marketkey := solana.PublicKey{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
	}

	key := EncodeFillData(marketkey, 3, 2)
	assert.Equal(t, Key([]byte{
		0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	}), key)
}

func TestDecodeFillData(t *testing.T) {
	market, orderSeqNum, slotNum := DecodeFillData([]byte{
		0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	})
	assert.Equal(t, solana.PublicKey{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
	}, market)
	assert.Equal(t, orderSeqNum, uint64(3))
	assert.Equal(t, slotNum, uint64(2))
}

func TestEncodeFillsByPubkey(t *testing.T) {
	pubkey := solana.PublicKey{
		0xaa, 0xbb, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	marketkey := solana.PublicKey{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
	}

	key := EncodeOrdersByPubkey(pubkey, marketkey, 3, 2)
	assert.Equal(t, Key([]byte{
		0x02,
		0xaa, 0xbb, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
	}), key)
}

func TestDecodeFillsByPubkey(t *testing.T) {
	pubkey, market, orderSeqNum, slotNum := DecodeOrdersByPubkey([]byte{
		0x02,
		0xaa, 0xbb, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
	})

	assert.Equal(t, solana.PublicKey{
		0xaa, 0xbb, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}, pubkey)

	assert.Equal(t, solana.PublicKey{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
	}, market)
	assert.Equal(t, orderSeqNum, uint64(3))
	assert.Equal(t, slotNum, uint64(2))
}

func TestEncodeFillsByMarketPubkey(t *testing.T) {
	pubkey := solana.PublicKey{
		0xaa, 0xbb, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	marketkey := solana.PublicKey{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
	}

	key := EncodeOrdersByMarketPubkey(pubkey, marketkey, 3, 2)
	assert.Equal(t, Key([]byte{
		0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
		0xaa, 0xbb, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
	}), key)
}

func TestDecodeFillsByMarketPubkey(t *testing.T) {
	pubkey, market, orderSeqNum, slotNum := DecodeOrdersByMarketPubkey([]byte{
		0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
		0xaa, 0xbb, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc})

	assert.Equal(t, solana.PublicKey{
		0xaa, 0xbb, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}, pubkey)

	assert.Equal(t, solana.PublicKey{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc,
	}, market)
	assert.Equal(t, orderSeqNum, uint64(3))
	assert.Equal(t, slotNum, uint64(2))
}

func TestHexToBase58String(t *testing.T) {

	hx := "1a387564848c21834eb4cdde0db9e23ec9a42fba5e5ee8c017c2bebe65defd24"
	//hx := "c849cbfee98c362c717fe8ad198d43e26db4965c28ab60f1aeb9597bcd3efcf4"
	//hx := "f4043a717d41ee6196ffff1c74e7f663f92cd690e5e5624c084b5fc3c464b5ea"
	data, err := hex.DecodeString(hx)
	require.NoError(t, err)
	pk := solana.PublicKeyFromBytes(data)
	fmt.Println(pk)
}

func TestDecodeOrdersByMarketPubkey(t *testing.T) {

	k, err := hex.DecodeString("021a387564848c21834eb4cdde0db9e23ec9a42fba5e5ee8c017c2bebe65defd24fffffffffc58fbd6c849cbfee98c362c717fe8ad198d43e26db4965c28ab60f1aeb9597bcd3efcf4000000000075eb56")
	require.NoError(t, err)

	trader, market, order, slot := DecodeOrdersByMarketPubkey(k)
	fmt.Println("trader:", trader, " market:", market, " order:", order, " slot:", slot)

}

func TestEncodeOrdersByPubkey(t *testing.T) {
	key := EncodeOrdersByMarketPubkey(solana.MustPublicKeyFromBase58("JEKNVniRRUh2JLBzRUBbcFebFjnBEa8UhoyoYNbPCueg"), solana.MustPublicKeyFromBase58("2mMXswJ7yyLwTHfv9YeZoKoEC8yeKxfFT8Qxx1g5cGo5"), 100, 1000)

	trader, market, order, slot := DecodeOrdersByMarketPubkey(key)
	fmt.Println("trader:", trader, " market:", market, " order:", order, " slot:", slot)
}

func TestDecodeFillData_FOO(t *testing.T) {

	key := EncodeFillData(solana.MustPublicKeyFromBase58("2mMXswJ7yyLwTHfv9YeZoKoEC8yeKxfFT8Qxx1g5cGo5"), 100, 1000)
	market, order, slot := DecodeFillData(key)

	assert.Equal(t, solana.MustPublicKeyFromBase58("2mMXswJ7yyLwTHfv9YeZoKoEC8yeKxfFT8Qxx1g5cGo5"), market)
	assert.Equal(t, uint64(100), order)
	assert.Equal(t, uint64(1000), slot)

	//keyData, err := hex.DecodeString("011a387564848c21834eb4cdde0db9e23ec9a42fba5e5ee8c017c2bebe65defd24ffffffffff8be22b5146a68432c1030b")
	//require.NoError(t, err)
	//market, order, slot := DecodeFillData(keyData)
	//fmt.Println("market:", market, " order:", order, " slot:", slot)
}
